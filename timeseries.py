# -*- coding: utf-8 -*-
"""timeseries.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H_-SUwJk5wwBtxI76Bu-rr1xKt9_2M9-
"""



import pandas as pd
import statsmodels
from statsmodels.tsa.ar_model import AutoReg
from pandas import read_csv
from matplotlib import pyplot
from pandas.plotting import lag_plot
from pandas.plotting import autocorrelation_plot
from statsmodels.graphics.tsaplots import plot_acf
from math import sqrt
from sklearn.metrics import mean_squared_error

data = read_csv('/Users/KenedyDucheine/PycharmProjects/timeseries/daily-min-temperatures.csv', header=0, index_col= 0)

"""#### Autocorrelation and lags"""

data.plot()
lag_plot(data) # checking for patterns and shape of data
# ac = corr between val1 and val1 at diff time in time series , lag = num of intevals between 2 data points
# linear shape -> ar model
# elliptical -> sinusoidal

plot_acf(data, lags = 3000)
## pos value means that val 1 increases and val 1 at diff time also increases (pos relationship)
## neg val means val 1 increases and val 1 at diff time decreases

"""#### Persistence model"""

## laged model
values = pd.DataFrame(data.values)
df = pd.concat([values.shift(1), values], axis = 1)
df.columns = ['t-1', 't+1']
X = df.values
train, test = X[1:(len(X)-7)], X[len(X)-7:]
train_x, train_y = train[:,0], train[:,1]
test_x, test_y = test[:,0], test[:,1]

def model_persistence(x):
  return(x)

## walk forward validation
predic_y = list()
for x in test_x:
  yhat = model_persistence(x)
  predic_y.append(yhat)

test_comparisions = mean_squared_error(test_y, predic_y)
print ('mse for testy and predicy is: %.3f' % test_comparisions)

"""#### AR model"""

series=read_csv('daily-min-temperatures.csv',header=0,index_col=0,parse_dates=True,squeeze=True)
X2=series.values
train2,test2=X2[1:len(X)-7],X2[len(X)-7:]

model=AutoReg(train2,lags=29)
model_fit = model.fit()
coefs = model_fit.params
print('Coefficients: %s' % coefs)

predictions=model_fit.predict(start=len(train2),end=len(train2)+len(test2)-1,
                              dynamic=False)
for i in range(len(predictions)):
  print('predicted=%f, expected=%f' % (predictions[i],test2[i]))

rmse = sqrt(mean_squared_error(test2,predictions))
print('Test RMSE: %.3f'%rmse)

pyplot.plot(test2)
pyplot.plot(predictions)